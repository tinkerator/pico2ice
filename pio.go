// Package pico2ice was autogenerated by the zappem.net/pub/io/pious package.
//
// From sources: pio/spi.pio,pio/clock.pio

package pico2ice

import (
	"machine"
	"sync"

	pio "github.com/tinygo-org/pio/rp2-pio"
)

// Engine is a wrapper type to enable pico2ice methods for a
// pio.PIO.
type Engine struct {
	block  *pio.PIO
	offset uint8
	mu     sync.Mutex
}

// StateMachine is a wrapper type to enable pico2ice methods
// for a pio.StateMachine.
type StateMachine struct {
	Origin uint8
	SM     *pio.StateMachine
	Cfg    pio.StateMachineConfig
}

// Start initializes and starts a StateMachine running a configured
// PIO sequence.
func (s *StateMachine) Start() {
	s.SM.Init(s.Origin, s.Cfg)
}

// Activate can be used to pause or resume a StateMachine.
func (s *StateMachine) Activate(run bool) {
	s.SM.SetEnabled(run)
}

// Assign loads the package program code into the block PIO.
func Assign(block *pio.PIO) (*Engine, error) {
	offset, err := block.AddProgram([]uint16{
		0x80a0,
		0x6040,
		0x6a01,
		0x9042,
		0x5a01,
		0x0082,
		0x8a42,
		0x9242,
		0x8242,
	}, -1)
	if err != nil {
		return nil, err
	}
	return &Engine{
		block:  block,
		offset: offset,
	}, nil
}

// ConfigureSpi sets up a spi module. It operates with
// an in size of ", m.In, " bits; an out size of ", m.Out, " bits;
// a side-set size of 1; and a pins set size of 0 bits.
func (e *Engine) ConfigureSpi(inBase, outBase, sideSetBase machine.Pin) (*StateMachine, error) {
	sm, err := e.block.ClaimStateMachine()
	if err != nil {
		return nil, err
	}
	cfg := pio.DefaultStateMachineConfig()
	cfg.SetWrap(e.offset+0, e.offset+5)
	var pin machine.Pin
	pin = sideSetBase
	for i := 0; i < 1; i++ {
		pin.Configure(machine.PinConfig{Mode: e.block.PinMode()})
		pin++
	}
	sm.SetPindirsConsecutive(sideSetBase, 1, true)
	cfg.SetSidesetPins(sideSetBase)
	cfg.SetSidesetParams(1, false, false)
	pin = outBase
	for i := 0; i < 1; i++ {
		pin.Configure(machine.PinConfig{Mode: e.block.PinMode()})
		pin++
	}
	sm.SetPindirsConsecutive(outBase, 1, true)
	cfg.SetOutPins(outBase, 1)
	cfg.SetOutShift(false, true, 8)
	pin = inBase
	for i := 0; i < 1; i++ {
		pin.Configure(machine.PinConfig{Mode: e.block.PinMode()})
		pin++
	}
	sm.SetPindirsConsecutive(inBase, 1, false)
	cfg.SetInPins(inBase, 1)
	cfg.SetInShift(false, true, 8)
	return &StateMachine{
		Origin: e.offset + 0,
		SM:     &sm,
		Cfg:    cfg,
	}, nil
}

// ConfigureClock sets up a clock module. It operates with
// an in size of ", m.In, " bits; an out size of ", m.Out, " bits;
// a side-set size of 1; and a pins set size of 0 bits.
func (e *Engine) ConfigureClock(sideSetBase machine.Pin) (*StateMachine, error) {
	sm, err := e.block.ClaimStateMachine()
	if err != nil {
		return nil, err
	}
	cfg := pio.DefaultStateMachineConfig()
	cfg.SetWrap(e.offset+7, e.offset+8)
	var pin machine.Pin
	pin = sideSetBase
	for i := 0; i < 1; i++ {
		pin.Configure(machine.PinConfig{Mode: e.block.PinMode()})
		pin++
	}
	sm.SetPindirsConsecutive(sideSetBase, 1, true)
	cfg.SetSidesetPins(sideSetBase)
	cfg.SetSidesetParams(1, false, false)
	return &StateMachine{
		Origin: e.offset + 6,
		SM:     &sm,
		Cfg:    cfg,
	}, nil
}
